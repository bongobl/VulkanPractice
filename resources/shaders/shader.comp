#version 450
#extension GL_ARB_separate_shader_objects: enable

#define		WORKGROUP_SIZE		32
#define		PI 					3.14159265358


layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;


struct Vertex{
	vec3 position;
	float mass;
	vec3 normal;
	float padding0;
	vec2 texCoord;
	vec2 padding1;
	vec3 velocity;
	float padding2;
};

//descriptor bindings
layout(std140, binding = 0) buffer buf
{
	Vertex physicsBuffer[];
};

layout(std140, binding = 1) buffer buf2
{
	Vertex vertexBuffer[];
};

layout(std140, binding = 2) uniform UniformBufferObject
{
	uint numParticles;
	uint pitch;
	float deltaTime;
	float netMass;
}ubo;

//use later
layout(std140, binding = 3) coherent buffer buf3
{
	vec4 netPosition;
}nextFrameInfo;

//main
void main(){
	
	if(gl_GlobalInvocationID.x >= ubo.pitch || gl_GlobalInvocationID.y >= ubo.pitch){
		return;
	}

	uint xVal = gl_GlobalInvocationID.x;
	uint yVal = gl_GlobalInvocationID.y;

	uint indexVal = yVal * ubo.pitch + xVal;

	if(indexVal > ubo.numParticles){
		return;
	}

	Vertex currVertex = physicsBuffer[indexVal];

	float angle = atan(currVertex.position.z, currVertex.position.x);
	float dist = pow( pow(currVertex.position.z, 2) + pow(currVertex.position.x, 2), 0.5f);
	float speed = ubo.deltaTime * 3000.0f / (pow(dist, 1.5f) * pow(currVertex.mass, 0.5f)) ;
	currVertex.position.x = dist * cos(angle + speed);
	currVertex.position.z = dist * sin(angle + speed);
	vertexBuffer[indexVal] = currVertex;

	//vertexBuffer[indexVal] = physicsBuffer[indexVal];


}