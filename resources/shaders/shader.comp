#version 450
#extension GL_ARB_separate_shader_objects: enable

#define		WORKGROUP_SIZE		32
#define		GRAV_CONSTANT 		24
#define 	CAGE_FORCE			0.2f

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;


struct Vertex{
	vec3 position;
	float mass;
	vec3 normal;
	float padding0;
	vec2 texCoord;
	vec2 padding1;
	vec3 velocity;
	float padding2;
};

//descriptor bindings
layout(std140, binding = 0) buffer buf
{
	Vertex physicsBuffer[];
};

layout(std140, binding = 1) buffer buf2
{
	Vertex vertexBuffer[];
};

layout(std140, binding = 2) uniform UniformBufferObject
{
	uint numParticles;
	uint pitch;
	float deltaTime;
	float netMass;

	int stride;
	vec3 padding;
}ubo;


//main
void main(){
	
	if(gl_GlobalInvocationID.x >= ubo.pitch || gl_GlobalInvocationID.y >= ubo.pitch){
		return;
	}

	uint xVal = gl_GlobalInvocationID.x;
	uint yVal = gl_GlobalInvocationID.y;

	uint indexVal = yVal * ubo.pitch + xVal;

	if(indexVal > ubo.numParticles){
		return;
	}

	Vertex currVertex = physicsBuffer[indexVal];
	

	//calculate net force on particle
	vec3 netForce = vec3(0,0,0);

	uint otherIndex = indexVal;
	for(int i = 0; i < ubo.numParticles; i += ubo.stride){

		Vertex otherVertex = physicsBuffer[otherIndex];

		if(otherVertex.position != currVertex.position){
			vec3 forceDir = otherVertex.position - currVertex.position;
			float forceMag = otherVertex.mass / (length(forceDir) * length(forceDir));
			netForce += forceMag * normalize(forceDir);
		}

		otherIndex += ubo.stride;
		if(otherIndex > ubo.numParticles){
			otherIndex -= ubo.numParticles;
		}
	}

	netForce = netForce * ubo.stride;
	netForce = netForce * GRAV_CONSTANT * currVertex.mass;
	netForce += -currVertex.position * currVertex.mass * CAGE_FORCE;
	netForce += 2.0f * -currVertex.velocity;

	//calc particle's acceleration
	vec3 acc = netForce / currVertex.mass;

	//calc new velocity
	vec3 oldVelocity = currVertex.velocity;
	currVertex.velocity = currVertex.velocity + acc * ubo.deltaTime;

	//calc new position
	currVertex.position = currVertex.position + oldVelocity * ubo.deltaTime + 0.5f * acc * ubo.deltaTime * ubo.deltaTime;

	//assign to particle in vertex buffer
	vertexBuffer[indexVal] = currVertex;
}