#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

struct Pixel{
  vec4 value;
};

layout(std140, binding = 0) buffer buf
{
   Pixel inputImageData[];
};

layout(std140, binding = 1) uniform UniformBufferObject
{
  
  uint colorR;
  uint colorG;
  uint colorB;
  uint alpha;


  uint width;
  uint height;
  float saturation;
  float padding2;

}ubo;

layout(std140, binding = 2) buffer buf2
{
   Pixel outputImageData[];
};

vec4 lerp(vec4 first, vec4 second, float param){
	return (1.0 - param) * first + param * second;
}

vec4 clamp_0_255(vec4 raw){
	vec4 retVal = raw;

	if(retVal.r > 255)	retVal.r = 255;
	if(retVal.r < 0) retVal.r = 0;
	if(retVal.g > 255)	retVal.g = 255;
	if(retVal.g < 0) retVal.g = 0;
	if(retVal.b > 255)	retVal.b = 255;
	if(retVal.b < 0) retVal.b = 0;
	if(retVal.a > 255)	retVal.a = 255;
	if(retVal.a < 0) retVal.a = 0;

	return retVal;
}

void main() {


	//In order to fit the work into workgroups, some unnecessary threads are launched.
	//We terminate those threads here. 
	if(gl_GlobalInvocationID.x >= ubo.width || gl_GlobalInvocationID.y >= ubo.height){
	return;
	}

	//get image coordinates in range 0-1
	float x = float(gl_GlobalInvocationID.x) / float(ubo.width);
	float y = float(gl_GlobalInvocationID.y) / float(ubo.height);


	int imageIndex = int(ubo.width * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x);

	
	
	float averageLum = (inputImageData[imageIndex].value.r + inputImageData[imageIndex].value.g + inputImageData[imageIndex].value.b) / 3;
	vec4 grayScale = vec4(averageLum, averageLum, averageLum, inputImageData[imageIndex].value.a);
	outputImageData[imageIndex].value = clamp_0_255( lerp(grayScale, inputImageData[imageIndex].value, ubo.saturation) );


}

